<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Face Landmarker</title>
    <style>
        /* Hide the Canvas element initially */
        #outputCanvas {
            display: none;
        }
    </style>
</head>

<body>
    <canvas id="outputCanvas"></canvas>
    <!-- Include TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script type="module">
        // Import Mediapipe Tasks Vision module
        import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        let faceLandmarker = null;
        let models = {}; // Object to hold multiple models

        // Create FaceLandmarker instance
        async function createFaceLandmarker() {
            console.log('Creating FaceLandmarker...');
            try {
                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
                );
                faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'IMAGE',
                    numFaces: 1,
                });
                console.log('FaceLandmarker created');
            } catch (error) {
                console.error('Error creating FaceLandmarker:', error);
            }
        }

        // Load models (you can customize this function to load different models)
        async function loadModels() {
            console.log('Loading custom models...');
            const modelNames = ['facing-model']; // List of model names
            for (let modelName of modelNames) {
                const indexedDBUrl = `indexeddb://${modelName}`;
                try {
                    // Try to load the model from IndexedDB
                    let model = await tf.loadGraphModel(indexedDBUrl);
                    console.log(`Custom model ${modelName} loaded successfully from IndexedDB`);
                    models[modelName] = model;
                } catch (error) {
                    console.warn(`Could not load model ${modelName} from IndexedDB, loading from network...`, error);
                    try {
                        // Load from the network (replace with actual URL)
                        const networkModelUrl = `https://nkust.suko.zip/models/${modelName}/model.json`;
                        let model = await tf.loadGraphModel(networkModelUrl);
                        console.log(`Custom model ${modelName} loaded successfully from network`);
                        // Save the model to IndexedDB for offline use
                        await model.save(indexedDBUrl);
                        console.log(`Custom model ${modelName} saved to IndexedDB`);
                        models[modelName] = model;
                    } catch (networkError) {
                        console.error(`Error loading custom model ${modelName} from network:`, networkError);
                    }
                }
            }
        }

        // Preprocess landmarks
        function preprocessLandmarks(landmarks) {
            const input = [];
            for (let i = 0; i < landmarks.length; i++) {
                input.push(landmarks[i].x);
                input.push(landmarks[i].y);
                input.push(landmarks[i].z);
            }

            while (input.length < 468 * 3) {
                input.push(0, 0, 0);
            }

            if (input.length > 468 * 3) {
                input.length = 468 * 3;
            }

            const inputTensor = tf.tensor(input, [1, 468 * 3]);
            return inputTensor;
        }

        // Run model and get predictions
        function runModel(inputTensor, modelName) {
            let model = models[modelName];
            if (!model) {
                console.error(`Custom model ${modelName} not loaded`);
                return;
            }

            try {
                const inputName = model.inputs[0].name;
                const prediction = model.execute({ [inputName]: inputTensor });

                let predictionData;
                if (Array.isArray(prediction)) {
                    predictionData = [];
                    for (let tensor of prediction) {
                        const data = tensor.dataSync();
                        predictionData = predictionData.concat(Array.from(data));
                        tensor.dispose();
                    }
                } else {
                    predictionData = prediction.dataSync();
                    prediction.dispose();
                }

                return predictionData;
            } catch (error) {
                console.error(`Error during model ${modelName} execution:`, error);
                if (error.stack) {
                    console.error('Stack trace:', error.stack);
                }
            }
        }

        // Main processing function
        async function processImage(imageData, isShowFaceMesh) {
            if (!faceLandmarker || Object.keys(models).length === 0) {
                console.error('FaceLandmarker or custom models not initialized');
                return null;
            }

            try {
                const results = await faceLandmarker.detect(imageData);

                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];
                    const limitedLandmarks = landmarks.slice(0, 468);

                    // Preprocess landmarks
                    const inputTensor = preprocessLandmarks(limitedLandmarks);

                    // Run models and collect predictions
                    let allPredictions = [];
                    for (let modelName in models) {
                        const predictions = runModel(inputTensor, modelName);
                        if (predictions) {
                            allPredictions = allPredictions.concat(predictions);
                        }
                    }

                    // Return all predictions
                    return allPredictions;
                } else {
                    console.log('No face landmarks detected.');
                    return null;
                }
            } catch (error) {
                console.error('Error during faceLandmarker.detect:', error);
                return null;
            }
        }

        // Function exposed to Swift to process image data
        function processImageData(base64Image) {
            try {
                const image = new Image();
                image.src = 'data:image/jpeg;base64,' + base64Image;

                image.onload = async () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');

                    // Flip the image vertically (Y-axis flip)
                    ctx.scale(1, -1);
                    ctx.drawImage(image, 0, -canvas.height, canvas.width, canvas.height);

                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    try {
                        const predictions = await processImage(imageData);

                        if (predictions) {
                            window.webkit.messageHandlers.callbackHandler.postMessage(predictions.join(','));
                        } else {
                            window.webkit.messageHandlers.callbackHandler.postMessage('null');
                        }
                    } catch (error) {
                        console.error('Error during image processing:', error);
                        window.webkit.messageHandlers.callbackHandler.postMessage('null');
                    }
                };

                image.onerror = (error) => {
                    console.error('Image load error:', error);
                    window.webkit.messageHandlers.callbackHandler.postMessage('null');
                };
            } catch (error) {
                console.error('Error in processImageData:', error);
                window.webkit.messageHandlers.callbackHandler.postMessage('null');
            }
        }

        // Initialization function
        async function initialize() {
            console.log('Initializing...');
            await createFaceLandmarker();
            await loadModels();
            console.log('Initialization complete');
        }

        // Initialize
        initialize();
        window.processImageData = processImageData;
    </script>
</body>

</html>
